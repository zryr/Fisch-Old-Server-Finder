-- Load script functions from the URL
local scriptFunctions = loadstring(game:HttpGet("https://raw.githubusercontent.com/zryr/Fisch-Old-Server-Finder/refs/heads/main/Source-Khalid"))()

-- Assuming the loaded script has a checkUptime function
scriptFunctions.checkUptime = function(desiredMinUptime)
    local TeleportService = game:GetService("TeleportService")
    local HttpService = game:GetService("HttpService")
    local player = game.Players.LocalPlayer
    local visitedServersFile = "visited_servers.txt"
    local visitedServers = {}

    -- Initial wait before starting the script logic
    wait(2)

    -- Check if the script is executed on the correct PlaceId
    local expectedPlaceId = 16732694052
    if game.PlaceId ~= expectedPlaceId then
        local notificationLibrary = loadstring(game:HttpGet("https://raw.githubusercontent.com/laagginq/ui-libraries/main/xaxas-notification/src.lua"))()
        local notifications = notificationLibrary.new({
            NotificationLifetime = 3,
            NotificationPosition = "Middle",
            TextFont = Enum.Font.Code,
            TextColor = Color3.fromRGB(255, 255, 255),
            TextSize = 15,
            TextStrokeTransparency = 0,
            TextStrokeColor = Color3.fromRGB(0, 0, 0)
        })

        notifications:BuildNotificationUI()
        notifications:Notify("This script is for Fisch only!")
        return
    end

    -- Read visited server IDs and their uptimes from file or create the file if it doesn't exist
    local function loadVisitedServers()
        if pcall(function() return readfile(visitedServersFile) end) then
            local data = readfile(visitedServersFile)
            for line in string.gmatch(data, "[^\n]+") do
                local serverId, uptime, timestamp = line:match("([^|]+)%s*|%s*(%d+:%d+:%d+)%s*|%s*([%d:]+%s*[AP]M %[UTC%])")
                if serverId and uptime and timestamp then
                    visitedServers[serverId] = {uptime = uptime, timestamp = timestamp}
                end
            end
        else
            -- Create a new file if it doesn't exist
            writefile(visitedServersFile, "")
            print("Created new visited servers file.")
        end
    end

    -- Write visited server IDs, their uptimes, and timestamps to file
    local function saveVisitedServers()
        local data = ""
        for serverId, info in pairs(visitedServers) do
            local uptime, timestamp = info.uptime, info.timestamp
            -- Convert uptime to string if it's a boolean
            if type(uptime) == "boolean" then
                uptime = tostring(uptime)
            end
            data = data .. serverId .. " | " .. uptime .. " | " .. timestamp .. "\n"
        end
        writefile(visitedServersFile, data)
        print("Saved visited server ID, uptime, and timestamp.")
    end

    loadVisitedServers()  -- Load visited servers at the start

    local function getServerUptimeFromGUI()
        local uptimeLabel = player.PlayerGui:WaitForChild("serverInfo"):WaitForChild("serverInfo"):WaitForChild("uptime")
        local uptimeText = uptimeLabel.Text
        local timeStr = uptimeText:match("(%d+:%d+:%d+)")
        return timeStr
    end

    local function toClipboard(text)
        setclipboard(text)
    end

    local function flashScreenUntilInteraction()
        local screenGui = Instance.new("ScreenGui")
        screenGui.DisplayOrder = 1000  -- High display order to ensure it overlays above other GUI elements
        screenGui.Parent = player.PlayerGui
        screenGui.IgnoreGuiInset = true

        local flashButton = Instance.new("TextButton")
        flashButton.Size = UDim2.new(1, 0, 1, 0)
        flashButton.BackgroundColor3 = Color3.new(1, 1, 1)
        flashButton.BorderSizePixel = 0
        flashButton.Text = ""  -- No text to make it appear as a plain white overlay
        flashButton.Parent = screenGui

        -- Debug statements
        print("Flash screen button created. Waiting for user interaction to stop flashing...")

        local flashing = true

        local function removeFlash()
            print("User interaction detected. Stopping flash screen.")
            flashing = false
            screenGui:Destroy()
        end

        flashButton.MouseButton1Click:Connect(removeFlash) -- Remove on user interaction

        -- Create a flashing effect
        while flashing do
            flashButton.Visible = not flashButton.Visible
            wait(0.5) -- Flash interval; adjust this to make it faster or slower
        end
    end

    local function serverHop()
        local gameId = game.PlaceId
        local cursor = ""
        local serversUrlPattern = "https://games.roblox.com/v1/games/" .. gameId .. "/servers/Public?sortOrder=Asc&limit=100&cursor=%s"

        while true do
            local serversUrl = serversUrlPattern:format(cursor)
            local success, result = pcall(function()
                return HttpService:JSONDecode(game:HttpGet(serversUrl))
            end)

            if success and result.data then
                for _, server in ipairs(result.data) do
                    if server.id ~= game.JobId and not server.private and not visitedServers[server.id] then
                        visitedServers[server.id] = {uptime = "00:00:00", timestamp = os.date("!%I:%M:%S %p [UTC]")}
                        saveVisitedServers()  -- Save visited servers to file

                        local successJoin, errorMessage
                        repeat
                            successJoin, errorMessage = pcall(function()
                                TeleportService:TeleportToPlaceInstance(gameId, server.id, player)
                            end)
                            if not successJoin then
                                print("Teleport Error: " .. tostring(errorMessage) .. ". Retrying...")
                                wait(2) -- Wait a bit before retrying
                            end
                        until successJoin

                        return
                    end
                end

                if result.nextPageCursor then
                    cursor = result.nextPageCursor
                else
                    cursor = ""  -- Reset cursor to start over
                end
            end

            wait(2)
        end
    end

    local function checkCurrentServer()
        local serverUptime = getServerUptimeFromGUI()

        -- Output the initial uptime without the server info text
        print("Initial Server Uptime: " .. serverUptime)
        
        -- If the uptime is 00:00:00, wait and check again
        if serverUptime == "00:00:00" then
            warn("Server uptime not loaded. Current uptime is 00:00:00.")
            
            -- Wait for 5 seconds
            wait(5)

            -- Output the uptime again
            serverUptime = getServerUptimeFromGUI()
            print("Checked Server Uptime: " .. serverUptime)

            if serverUptime == "00:00:00" then
                warn("Server uptime still not loaded. Current uptime is 00:00:00.")
                serverHop()
                return
            end
        end

        local currentServerId = game.JobId

        if serverUptime >= desiredMinUptime then
            toClipboard(currentServerId)
            flashScreenUntilInteraction()
            print("Old server has been found, you're welcome!")
        else
            -- Save the current server's uptime in hh:mm:ss format and log the timestamp
            visitedServers[currentServerId] = {
                uptime = serverUptime,
                timestamp = os.date("!%I:%M:%S %p [UTC]")
            }
            saveVisitedServers()
            serverHop()
        end
    end

    checkCurrentServer()
end

-- Check server uptime with "hh:mm:ss" format
scriptFunctions.checkUptime("60:00:00") -- Set the desired minimum uptime in "hh:mm:ss" format (60 hours)
