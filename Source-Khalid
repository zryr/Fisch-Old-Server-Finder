-- Function to notify the user using the notification library
local function notify(title, message)
    local notificationLibrary = loadstring(game:HttpGet("https://raw.githubusercontent.com/laagginq/ui-libraries/main/xaxas-notification/src.lua"))()
    local notifications = notificationLibrary.new({
        NotificationLifetime = 3,
        NotificationPosition = "Middle",
        TextFont = Enum.Font.Code,
        TextColor = Color3.fromRGB(255, 255, 255),
        TextSize = 15,
        TextStrokeTransparency = 0,
        TextStrokeColor = Color3.fromRGB(0, 0, 0)
    })

    notifications:BuildNotificationUI()
    notifications:Notify(title, message) -- Ensure this passes title and message as separate string arguments
end

-- Unique key to identify if the script has been run in this session
local sessionKey = "autoexecute_session.txt"

-- Check if the session key file exists
local function hasRunThisSession()
    return isfile(sessionKey)
end

-- Mark this session as having run the script
local function markSessionAsRun()
    writefile(sessionKey, "1")
end

-- Function to check uptime
function checkUptime(desiredUptime)
    if hasRunThisSession() then
        notify("Info", "Script execution stopped for this session.")
        return
    end

    -- Mark as run to prevent further auto-execution in this session
    markSessionAsRun()

    local TeleportService = game:GetService("TeleportService")
    local HttpService = game:GetService("HttpService")
    local player = game.Players.LocalPlayer
    local visitedServersFile = "visited_servers.txt"
    local visitedServers = {}

    -- Initial wait before starting the script logic
    wait(2)

    -- Check if the script is executed on the correct PlaceId
    local expectedPlaceId = 16732694052
    if game.PlaceId ~= expectedPlaceId then
        notify("Error", "Wrong place! This script is for Fisch only!")
        return
    end

    -- Load visited servers from file
    local function loadVisitedServers()
        if pcall(function() return readfile(visitedServersFile) end) then
            local data = readfile(visitedServersFile)
            for line in string.gmatch(data, "[^\n]+") do
                local serverId, info = line:match("([^|]+)%s*|%s*(.*)")
                if serverId and info then
                    visitedServers[serverId] = info
                end
            end
        else
            writefile(visitedServersFile, "")
            notify("Info", "Created new visited servers file.")
        end
    end

    -- Save visited servers to file
    local function saveVisitedServers()
        local data = ""
        for serverId, info in pairs(visitedServers) do
            data = data .. serverId .. " | " .. info .. "\n"
        end
        writefile(visitedServersFile, data)
    end

    loadVisitedServers()

    -- Get server uptime from GUI
    local function getServerUptimeFromGUI()
        local uptimeLabel = player.PlayerGui:WaitForChild("serverInfo"):WaitForChild("serverInfo"):WaitForChild("uptime")
        local uptimeText = uptimeLabel.Text
        local timeStr = uptimeText:match("(%d+:%d+:%d+)")
        return timeStr
    end

    -- Get update version from GUI
    local function getUpdateVersionFromGUI()
        local versionLabel = player.PlayerGui:WaitForChild("serverInfo"):WaitForChild("serverInfo"):WaitForChild("version")
        local versionText = versionLabel.Text
        local versionStr = versionText:match("Update Version: (%d+%.%d+)")
        return versionStr
    end

    -- Copy text to clipboard
    local function toClipboard(text)
        setclipboard(text)
    end

    -- Flash screen until user interaction
    local function flashScreenUntilInteraction(callback)
        local screenGui = Instance.new("ScreenGui")
        screenGui.DisplayOrder = 1000
        screenGui.Parent = player.PlayerGui
        screenGui.IgnoreGuiInset = true

        local flashButton = Instance.new("TextButton")
        flashButton.Size = UDim2.new(1, 0, 1, 0)
        flashButton.BackgroundColor3 = Color3.new(1, 1, 1)
        flashButton.BorderSizePixel = 0
        flashButton.Text = ""
        flashButton.Parent = screenGui

        local flashing = true

        local function removeFlash()
            flashing = false
            screenGui:Destroy()
            if callback then
                callback() -- Trigger the notification after the flash screen is closed
            end
        end

        flashButton.MouseButton1Click:Connect(removeFlash)

        while flashing do
            flashButton.Visible = not flashButton.Visible
            wait(0.5)
        end
    end

    -- Server hop logic
    local function serverHop()
        local gameId = game.PlaceId
        local cursor = ""
        local serversUrlPattern = "https://games.roblox.com/v1/games/" .. gameId .. "/servers/Public?sortOrder=Asc&limit=100&cursor=%s"

        while true do
            local serversUrl = serversUrlPattern:format(cursor)
            local success, result = pcall(function()
                return HttpService:JSONDecode(game:HttpGet(serversUrl))
            end)

            if success and result.data then
                for _, server in ipairs(result.data) do
                    if server.id ~= game.JobId and not server.private and not visitedServers[server.id] and server.playing < server.maxPlayers then
                        local successJoin, errorMessage
                        repeat
                            successJoin, errorMessage = pcall(function()
                                TeleportService:TeleportToPlaceInstance(gameId, server.id, player)
                            end)
                            if not successJoin then
                                if errorMessage:match("GameFull") or errorMessage:match("Unauthorized") then
                                    wait(5)
                                    break -- Exit the retry loop to find a different server
                                else
                                    wait(5) -- Wait before retrying for other errors
                                end
                            end
                        until successJoin

                        if successJoin then
                            return
                        end
                    end
                end

                if result.nextPageCursor then
                    cursor = result.nextPageCursor
                else
                    cursor = ""
                end
            end

            wait(2)
        end
    end

    -- Check current server logic
    local function checkCurrentServer()
        local serverUptime = getServerUptimeFromGUI()
        local serverVersion = getUpdateVersionFromGUI()

        if serverUptime == "00:00:00" then
            wait(10)  -- Wait for 10 seconds to re-check
            serverUptime = getServerUptimeFromGUI()
            serverVersion = getUpdateVersionFromGUI()

            if serverUptime == "00:00:00" then
                visitedServers[game.JobId] = "(failed to get server info)"
                saveVisitedServers()
                serverHop()
                return
            end
        end

        local currentServerId = game.JobId
        local currentTimeUTC = os.date("!%I:%M:%S %p [UTC]")

        if serverUptime >= desiredUptime then
            toClipboard(currentServerId)
            flashScreenUntilInteraction(function()
                notify("Success", "Old server has been found, you're welcome!")
            end)
        else
            visitedServers[currentServerId] = serverUptime .. " | " .. (serverVersion or "Unknown Version") .. " | " .. currentTimeUTC
            saveVisitedServers()
            serverHop()
        end
    end

    checkCurrentServer()
end

-- Call the function with your desired uptime
checkUptime("60:00:00") -- Set the desired minimum uptime in "hh:mm:ss"

-- Prepare for server hop with auto-execution
local teleportScript = [[
    loadstring(game:HttpGet("https://raw.githubusercontent.com/zryr/Fisch-Old-Server-Finder/refs/heads/main/Source-Khalid"))()
    checkUptime("60:00:00")
]]

if syn and syn.queue_on_teleport then
    syn.queue_on_teleport(teleportScript)
elseif queue_on_teleport then
    queue_on_teleport(teleportScript)
else
    notify("Notice", "Put the script in your autoexecute folder.")
end
