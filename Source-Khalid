-- This script persists visited server IDs and their uptimes using local files and hops to servers in ascending order of players
return {
    checkUptime = function(desiredMinUptimeSeconds)
        local TeleportService = game:GetService("TeleportService")
        local HttpService = game:GetService("HttpService")
        local player = game.Players.LocalPlayer
        local visitedServersFile = "visited_servers.txt"
        local visitedServers = {}

        -- Check if the script is executed on the correct PlaceId
        local expectedPlaceId = 16732694052
        if game.PlaceId ~= expectedPlaceId then
            local notificationLibrary = loadstring(game:HttpGet("https://raw.githubusercontent.com/laagginq/ui-libraries/main/xaxas-notification/src.lua"))()
            local notifications = notificationLibrary.new({
                NotificationLifetime = 3,
                NotificationPosition = "Middle",
                TextFont = Enum.Font.Code,
                TextColor = Color3.fromRGB(255, 255, 255),
                TextSize = 15,
                TextStrokeTransparency = 0,
                TextStrokeColor = Color3.fromRGB(0, 0, 0)
            })

            notifications:BuildNotificationUI()
            notifications:Notify("This script is for Fisch only!")
            return
        end

        -- Read visited server IDs and their uptimes from file or create the file if it doesn't exist
        local function loadVisitedServers()
            if pcall(function() return readfile(visitedServersFile) end) then
                local data = readfile(visitedServersFile)
                for line in string.gmatch(data, "[^\n]+") do
                    local serverId, uptime, timestamp = line:match("([^|]+)%s*|%s*(%d+:%d+:%d+)%s*|%s*([%d:]+%s*[AP]M %[UTC%])")
                    if serverId and uptime and timestamp then
                        visitedServers[serverId] = {uptime = uptime, timestamp = timestamp}
                    end
                end
            else
                -- Create a new file if it doesn't exist
                writefile(visitedServersFile, "")
                print("Created new visited servers file.")
            end
        end

        -- Convert seconds to hh:mm:ss format
        local function formatTime(seconds)
            local hours = math.floor(seconds / 3600)
            local minutes = math.floor((seconds % 3600) / 60)
            local seconds = seconds % 60
            return string.format("%02d:%02d:%02d", hours, minutes, seconds)
        end

        -- Write visited server IDs, their uptimes, and timestamps to file
        local function saveVisitedServers()
            local data = ""
            for serverId, info in pairs(visitedServers) do
                local uptime, timestamp = info.uptime, info.timestamp
                -- Convert uptime to string if it's a boolean
                if type(uptime) == "boolean" then
                    uptime = tostring(uptime)
                end
                data = data .. serverId .. " | " .. uptime .. " | " .. timestamp .. "\n"
            end
            writefile(visitedServersFile, data)
            print("Saved visited server ID, uptime, and timestamp.")
        end

        loadVisitedServers()  -- Load visited servers at the start

        local function convertTimeToSeconds(timeStr)
            local hours, minutes, seconds = timeStr:match("(%d+):(%d+):(%d+)")
            hours = tonumber(hours) or 0
            minutes = tonumber(minutes) or 0
            seconds = tonumber(seconds) or 0
            return (hours * 3600) + (minutes * 60) + seconds
        end

        local function getServerUptimeFromGUI()
            local uptimeLabel = player.PlayerGui:WaitForChild("serverInfo"):WaitForChild("serverInfo"):WaitForChild("uptime")
            local uptimeText = uptimeLabel.Text
            local timeStr = uptimeText:match("Server Uptime:%s*(%d+:%d+:%d+)")
            return convertTimeToSeconds(timeStr)
        end

        local function toClipboard(text)
            setclipboard(text)
        end

        local function flashScreen()
            local screenGui = Instance.new("ScreenGui")
            screenGui.Parent = player.PlayerGui
            screenGui.IgnoreGuiInset = true

            local flashFrame = Instance.new("Frame")
            flashFrame.Size = UDim2.new(1, 0, 1, 0)
            flashFrame.BackgroundColor3 = Color3.new(1, 1, 1)
            flashFrame.BorderSizePixel = 0
            flashFrame.Parent = screenGui

            for i = 1, 5 do
                flashFrame.Visible = true
                wait(0.2)
                flashFrame.Visible = false
                wait(0.2)
            end

            screenGui:Destroy()
        end

        local function serverHop()
            local gameId = game.PlaceId
            local cursor = ""
            local serversUrlPattern = "https://games.roblox.com/v1/games/" .. gameId .. "/servers/Public?sortOrder=Asc&limit=100&cursor=%s"

            while true do
                local serversUrl = serversUrlPattern:format(cursor)
                local success, result = pcall(function()
                    return HttpService:JSONDecode(game:HttpGet(serversUrl))
                end)

                if success and result.data then
                    for _, server in ipairs(result.data) do
                        if server.id ~= game.JobId and not server.private and not visitedServers[server.id] then
                            visitedServers[server.id] = {uptime = formatTime(0), timestamp = os.date("!%I:%M:%S %p [UTC]")}
                            saveVisitedServers()  -- Save visited servers to file

                            local successJoin, errorMessage = pcall(function()
                                TeleportService:TeleportToPlaceInstance(gameId, server.id, player)
                            end)
                            if successJoin then
                                return
                            end
                        end
                    end

                    if result.nextPageCursor then
                        cursor = result.nextPageCursor
                    else
                        cursor = ""  -- Reset cursor to start over
                    end
                end

                wait(2)
            end
        end

        local function checkCurrentServer()
            local serverUptimeSeconds = getServerUptimeFromGUI()
            
            -- Wait for the server uptime to change from 0:0:0 for up to 30 seconds
            local maxWaitTime = 30
            local elapsedTime = 0

            while serverUptimeSeconds == 0 and elapsedTime < maxWaitTime do
                wait(1)
                elapsedTime = elapsedTime + 1
                serverUptimeSeconds = getServerUptimeFromGUI()
            end

            local currentServerId = game.JobId

            -- Save the current server's uptime in hh:mm:ss format and log the timestamp
            visitedServers[currentServerId] = {
                uptime = formatTime(serverUptimeSeconds),
                timestamp = os.date("!%I:%M:%S %p [UTC]")
            }
            saveVisitedServers()

            if serverUptimeSeconds >= desiredMinUptimeSeconds then
                toClipboard(currentServerId)
                flashScreen()
            else
                serverHop()
            end
        end

        checkCurrentServer()
    end
}
